End to End Data Transformation Project with DBT & DuckDB
Project Name: nyc_yellow_taxi
Database type: duckdb


Project 1 (model): model a dbt table/view of all the data in the parquet 'taxi_rides_raw'


Project 2 (Update):
Your team lead just forwarded you an email with a data request from the marketing department. They'd like to count all the credit card users by day be available in the data warehouse and automatically updated based on the current dbt models. 
The new model should be called total_creditcard_riders_by_day and contain columns for day and total_riders
There is currently a model (meaning a SQL table) available under the name taxi_rides_raw that you can query against. 

Task (update):
Update the SQL model code with the requirements listed above, using the NYC Yellow Taxi data schema to determine how to filter the model.
Initiate the dbt command to execute the model.
Run the validation command ./datacheck in the nyc_yellow_taxi directory to check the contents match.


Project 3 (update Model Hierachy): 
You've successfully created and updated a couple of models in your dbt project. Your manager has asked that you verify all models will be generated in the appropriate order so that there are no errors during the materialization process. 

Task 3:
Update the SQL to use a Jinja ref template and save the file.
Rerun your dbt project to verify the error has been remedied. This time, include the -f switch to guarantee everything is updated.



Project 4(Defining Builtin-tests on a model):
After learning about tests within dbt, your manager has asked you to implement some quality tests on the data used by the marketing department. It seems some entries are appearing without values, while others have a value, but do not match up with what's expected in the data.

Task 4: Specifically, the issues with the columns are as follows:
fare_amount:
	Column is occasionally blank, which causes issues in other calculations.
	Should be present for all rows.
payment_type:
	Column values need to be between 1 and 6.
	Should be present for all rows.


Project 5(singular Test):
Your teammate stops by your desk to discuss an issue being seen in the source data. 
He describes how on some rows, the duration of the trip occasionally shows as 0. While it could be filtered at the source data level, there are some downstream models that are storing the bad rows for discussion with the data provider. 
As such, he'd like you to develop a test that fails for triggering purposes if there's ever data where the trip duration is 0. You agree to look at the issue and implement the test code.

Looking at the schema for the taxi_rides_raw model, you realize there's not really a single field representing the trip duration. After discussing it further with your colleague, the primary issue seems to be that the trip start and end fields are the same. You realize you can quickly write a query to check for this.


Task 5:
Open the test file named assert_trip_duration_gt_0.sql in the test directory.
Update the SQL statement to verify that the start and end values for the trip are not equal.
Execute just your validation using the appropriate command and verify how many rows fail the test.


Project 6 (reusable Test):
After learning about reusable tests, you realize that you'd love to build an in-house set of common tests for you and your team to use as you see fit. You notice that your datasets have several scenarios where you want to verify the columns contain values greater than 0. You decide to start your library by writing a reusable test for this purpose.

Task 6:
In the file check_gt_0.sql, update the test file to check for the appropriate values. 
Add the test to the columns fare_amount and total_amount on the taxi_rides_raw table.
Materialize your data within dbt prior to testing your data. TIp: dbt run
Run the appropriate dbt test command to determine if there are any errors in the newly created .sql file.


Project 7 (Adding a source):
you've learned about dbt sources, your manager has asked that you re-implement the taxi_rides_raw content as a dbt source rather than simply an existing table. 
To make this change, you'll need to add a source to the appropriate file, and then update the taxi_rides_raw model to query the correct source.
The source name being used is raw, and the table name is taxi_rides

Task 7:
Modify the models/source_properties.yml to add the source under raw.taxi_rides.
Update the taxi_rides_raw model to query the new source.
Tell dbt to generate the model using the appropriate subcommand. dbt run
Run the ./datacheck program to verify your data is as expected.

Project 8 (Seeds in dbt):
In preparation for your dbt projects, you realize that having a list of New York & New Jersey zip (postal) codes and some additional information would be good to add. Reading through the information, you realize that utilizing the dbt seed functionality would be a great way to add this information. The format of the zip file in question is: [zipcode,place,state]

Task 8:
Move the csv file nynj_zipcodes.csv into the appropriate subdirectory.
Update the appropriate .yml file to define the zipcode column to preserve any leading zeros.
Run the dbt seed command to generate the seed.
Run the ./datacheck command to verify the data is available in your data warehouse.


Project 9 (Adding a snapshot):
When working with your team, you learn about a new tangential dataset being added to the data warehouse.
This dataset represents the set of vehicles that will be in use for a given taxi license.
 While a taxi is likely to be used for quite some time, it is possible that the license may be reassigned to a new vehicle during a given timeframe.
 One of your colleagues realizes this may cause issues with future reporting as a ride may not be represented by the proper vehicle.
The dataset looks like the following:
column_name	description
license_id	The numeric ID assigned to the taxi company
vehicle_make	The manufacturer of the vehicle
vehicle_model	The model of the vehicle
vehicle_year	The year the vehicle was manufactured
last_updated	Date when the record was last modified

Looking at this information you realize this is a great time to implement snapshots using dbt. 
After discussing this with the team, your team lead asks you to implement the snapshot functionality in the nyc_yellow_taxi project, using the source named 'raw.vehicle_list'

Task 9:
Add the snapshot directive to the vehicle_list_snapshot snapshot definition.
Update the config directive to use the proper entries based on the columns in the raw.vehicle_list source.
Write a query to find all rows from the source.
Run the appropriate command to generate the snapshot.


Project 10 (DBT Build):
After learning about dbt, you've successfully implemented several projects with your team.
As your knowledge has increased, your status as a solid dbt practitioner has developed with the rest of the team. 
One of the interns has tried re-implementing a project from scratch, but is having issues getting the project to compile. 
Your team lead has asked you to take a look and fix the known issues in the project.

Task 10:
Execute the dbt command as you would in production. (tip: dbt build)
Look for any errors related to snapshots and fix these.
Re-execute the production dbt command.
Check for any further errors, fix these and re-run the appropriate command once more.
